%!TEX root=../../autopilot.tex
\section{Flexibility}
\label{sec:flexibility}

\subsection{Single-language}
\label{sec:singlelanguage}

Behavior software that uses dedicated microprocessors must have some routine for compiling the high-level abstraction of the experiment into machine code. This gives those systems a theoretical advantage in processing speed, but the compiler becomes the bottleneck of complexity: only those things that can be compiled can be included in the experiment. This may in part contribute to the ubiquity of state-machine formalisms in behavior software.

Because Python is used throughout the system, extending Autopilot's functionality is straightforward. Task design (see section \hyperref[sec:tasks]{\ref*{sec:tasks}}) is effectively arbitrary---anything that can be expressed in Python is a valid task. This also allows Autopilot to easily be extended to make use of external libraries (eg. our integration with DeepLabCut-Live\citep{kaneRealtimeLowlatencyClosedloop2020a} and our \hyperref[item:othertools]{planned} integration with OpenEphys).

\subsection{Modularity}

Although Autopilot deeply integrates with the Raspberry Pi's hardware, we have also worked to make its components modular. There is a tension between providing a full-featured behavioral system and the flexibility of its components --- as additional features are added to a system, they can constrain the functionality of existing components that they rely on. To address this tension, we have continuously worked to decouple Autopilot into subcomponents with clear inheritance hierarchies and APIs that can used quasi-independently. 

Modularity has 3 primary advantages:
\begin{enumerate}
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_1_alt.pdf}}\textbf{makes code more flexible} by reducing the constraints imposed by unstructured code interdependencies
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_2.pdf}}\textbf{makes code more intelligible} by logically distributing tasks to discrete classes
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_3.pdf}}\textbf{reduces effort-duplication} by allowing multiple, similar classes to be created with inheritance rather than copying and pasting.
\end{enumerate}

There is no such thing as "incompatible hardware" with Autopilot because the classes that control hardware are independent from the code that provides other core functionality. In systems without modular design, hardware implementation is spread across the codebase. For example to add a new type of hardware output to a Bpod system, one would need to write new firmware for it in C (eg. the \href{https://github.com/sanworks/Bpod\_ValveDriver\_Firmware}{valve driver module}), \href{https://github.com/sanworks/Bpod_StateMachine_Firmware/blob/v22/Preconfigured/StateMachine-Bpod2_0/StateMachine-Bpod2_0.ino}{modify Bpod's existing firmware}, hunt through the code to modify how \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/State\%20Machine\%20Assembler/AddState.m#L170}{states are added} and \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/\%40BpodObject/SetupStateMachine.m#L123}{state machines are assembled}, add its controls explicitly \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/Override\%20Panels/StateMachinePanel_2_0_0.m}{to the GUI}, and so on. 

Tasks specify what type of hardware is needed to run them, but are agnostic about the way the hardware is implemented, making their descriptions more portable. Tasks that have the same structure but differ in hardware (eg. a freely moving two-alternative forced choice task in which a mouse visits several IR sensors, or a head-fixed two-alternative forced choice task in which a mouse runs on a wheel to indicate its choice) can be implemented by a trivial subclass that modifies  the hardware description rather than completely rewriting the task.

\subsection{Plugins \& Code Transparency}
\label{sec:expansion}

We call Autopilot a software framework because in addition to providing classes and methods to run experiments out of the box, it also provides explicit structure that scaffolds any additional code that is needed by the user. Our goal is to clearly articulate in the documentation how modules should interact so that anyone can write code that works on any apparatus. 

As groupware intended to be used differently by lab members with different responsibilities, Autopilot is designed for users with a range of programming expertise, from those who only want to interact with a GUI, to those who wish to fundamentally rewrite core operations for their particular experiment. As such, it is extensively documented: this paper provides a high-level introduction to its design and structure, its user guide describes how to use the program and provides examples, and its API-level documentation describes in granular detail how the program actually works\sidenote{The user guide and API documentation are available at \url{docs.auto-pi-lot.com}}. Nothing is "off-limits" to the user---there isn't any hidden, undocumented hardware code behind the curtain\sidenote{For readability of the docs, we omit generating HTML documentation for some private methods and functions, but they are documented in the source and their function is made clear from their context and the documentation of public methods.}. We want users to be able to understand how and why everything works the way it does so that Autopilot can be adapted and expanded to any use-case.

A broader goal of Autopilot is to build a library of flexible task prototypes that can be tweaked and adapted, hopefully reducing the number of times the wheel is reinvented. We have attempted to nudge users to write reusable tasks by designing Autopilot such that rather than writing tasks as local unstructured scripts, they use its plugin system that scaffolds development by extending any of its basic types. Plugins are registered using a form in the Autopilot Wiki which makes them \href{https://wiki.auto-pi-lot.com/index.php/Autopilot_Plugins}{available to anyone} while also embedding them in a semantically annotated information system that allows giving explicit credit to contributors, programmatically linking to any derivative publications that use the plugin, and further documentation of any tasks, hardware, or other extensions included within the plugin. Inheriting from parent classes give plugins structure and a set of basic features\sidenote{Like inheriting from the \texttt{\href{https://docs.auto-pi-lot.com/en/latest/hardware/gpio.html\#autopilot.hardware.gpio.GPIO}{GPIO}} class gives GPIO plugins a systematic means of interacting with the underlying pigpiod daemon.} while also being maximally permissive --- anything can be overridden and modified.

\subsection{Message Handling}
\label{sec:message_handling}

Modular software needs a well-defined protocol to communicate between modules, and Autopilot's is heavily influenced by the concurrency philosophy\sidenote{"ZeroMQ [...] has a subversive effect on how you develop network-capable applications. [...] message processing rapidly becomes the central loop, and your application soon breaks down into a set of message processing tasks."\\"If there's one lesson we've learned from 30+ years of concurrent programming, it is: \textit{just don't share state.}"\\\vspace{6pt}\hspace*{\fill} -\href{http://zguide.zeromq.org/}{The ZeroMQ Guide}} of ZeroMQ\citep{hintjensZeroMQMessagingMany2013}. All communication between computers and modules happens with ZeroMQ messages, and handling those messages is the main way that Autopilot handles events. A key design principle is that Autopilot components should not "share state"---they can communicate, but they are not \textit{dependent} on one another. While this may seem like a trivial detail, having networking and message-handling at its core has three advantages that make Autopilot a fundamental departure from previous behavioral software.

First, new software modules can be added to any system by simply dropping in a standalone networking object. There is no need to dramatically reorganize existing code to make room for new functionality. Instead new modules can receive, process, and send information by just connecting to another module in the swarm. For example, each \hyperref[sec:plotting]{plot} opens a network connection to stream incoming task data independently from the stream that is saving the data.

Second, Autopilot can be made to interact with other software libraries that use ZeroMQ. For example, The OpenEphys GUI for electrophysiology \href{https://open-ephys.atlassian.net/wiki/spaces/OEW/pages/23265310/Network+Events}{can send and receive ZMQ messages} to execute actions such as starting or stopping recordings. Interaction with other software is also useful in the case that some expensive computation needs to happen mid-task. For example, one could send frames captured from a video camera on a Raspberry Pi to a GPU computing cluster for tracking the position of the animal. Since ZeroMQ messages are just TCP packets it is also possible to communicate over the internet for remote control or to communicate with a data server.

Third, making every component network-capable allows tasks to be distributed over multiple Raspberry Pis. Chaining multiple Pis distributes the computational load, allowing, for example, one Raspberry Pi to record and process video while another runs a sound server and delivers rewards. Autopilot expands with the complexity of your task, simultaneously eliminating limitations on quantity of hardware peripherals while ensuring latency is minimal. More interestingly, distributing tasks allows the arbitrary construction of what we call "behavioral topologies," which we describe in \hyperref[sec:topology]{section \ref*{sec:topology}}.
