
\section{Flexibility}
\label{sec:flexibility}

\subsection{Single-language}
\label{sec:singlelanguage}

Behavior software that uses dedicated microprocessors like Bpod must have some routine for compiling the high-level abstraction of the experiment into machine code. This gives those systems a theoretical advantage in processing speed, but the compiler becomes the bottleneck of complexity: only those things that can be compiled can be included in the experiment. This may in part contribute to the ubiquity of state-machine formalisms in behavior software.

Because Python is used throughout the system, extending Autopilot's functionality is straightforward. Task design (see section \hyperref[sec:tasks]{\ref*{sec:tasks}}) is effectively arbitrary---anything that can be expressed in Python is a valid task. Hardware can also be implemented arbitrarily, including hardware that makes use of external libraries (eg. ACQ4\citep{campagnolaACQ4OpensourceSoftware2014} and our \hyperref[item:othertools]{planned} integration with OpenEphys).


\subsection{Modularity}

Although Autopilot deeply integrates with the Raspberry Pi's hardware, we have also worked to make its components modular. Modularity has 3 primary advantages:
\begin{enumerate}
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_1_alt.pdf}}\textbf{makes code more flexible} by reducing the constraints imposed by unstructured code interdependencies
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_2.pdf}}\textbf{makes code more intelligible} by logically distributing tasks to discrete classes
    \item \textbf{Modularity} \marginnote{\includegraphics[]{figures/side_modularity_3.pdf}}\textbf{reduces effort-duplication} by allowing multiple, similar classes to be created with inheritance rather than copying and pasting.
\end{enumerate}

There is no such thing as "incompatible hardware" with Autopilot because the classes that control hardware are independent from the code that provides other core functionality. In systems without modular design, hardware implementation is spread across the codebase; for example to add a new type of hardware output to a Bpod system, one would need to write \href{https://github.com/sanworks/Bpod_Gen2/blob/master/FIRMWARE\%20README.txt}{new firmware for it in C}, \href{https://github.com/sanworks/Bpod_StateMachine_Firmware/blob/v22/Preconfigured/StateMachine-Bpod2_0/StateMachine-Bpod2_0.ino}{modify Bpod's existing firmware}, hunt through the code to modify how \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/State\%20Machine\%20Assembler/AddState.m#L170}{states are added} and \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/\%40BpodObject/SetupStateMachine.m#L123}{state machines are assembled}, add its controls explicitly \href{https://github.com/sanworks/Bpod_Gen2/blob/71f3a256b68926b65eae71e10fd747bd28e7ba7d/Functions/Override\%20Panels/StateMachinePanel_2_0_0.m}{to the GUI}, and so on. 

Tasks specify what type of hardware is needed to run them, but are agnostic about the way the hardware is implemented, making their descriptions more portable. Tasks that have the same structure but differ in hardware (eg. a freely moving two-alternative forced choice task in which a mouse visits several IR sensors, or a head-fixed two-alternative forced choice task in which a mouse runs on a wheel to indicate its choice) can be implemented by a trivial subclass that modifies  the hardware description rather than completely rewriting the task.

\subsection{Structured Expansion \& Code Transparency}
\label{sec:expansion}

We call Autopilot a software framework because in addition to providing classes and methods to run experiments out of the box, it also provides explicit structure that scaffolds any additional code that is needed by the user. Our goal is to clearly articulate in the documentation how modules should interact so that anyone can write code that works on any apparatus. 

Autopilot is designed for users with a range of programming expertise, from those who only want to interact with a GUI, to those who wish to fundamentally rewrite core operations for their particular experiment. As such, it is extensively documented: this paper provides a high-level introduction to its design and structure, its user guide describes how to use the program and provides examples, and its API-level documentation describes in granular detail how the program actually works\sidenote{The user guide and API documentation are available at \url{docs.auto-pi-lot.com}}. Nothing is "off-limits" to the user---there isn't any hidden, undocumented hardware code behind the curtain. We want users to be able to understand how and why everything works the way it does so that Autopilot can be adapted and expanded to any use-case.

A broader goal of Autopilot is to build a library of flexible task prototypes that can be tweaked and adapted, hopefully reducing the number of times the wheel is reinvented. We have attempted to nudge users to write reusable tasks by designing Autopilot such that rather than writing separate task scripts that are loaded and run by the program, tasks are written into a fork\sidenote{Autopilot is version controlled using \href{https://git-scm.com/}{git}. Users develop tasks in a copy, or 'fork' of the library that keeps track of their changes so that they can later be re-integrated, or 'pulled', into the main library.} of the library itself. When publishing research that uses a particular task, users are incentivized to pull the changes they have made in their fork back into the central library because doing so makes that task available to anyone using Autopilot. Autopilot's documentation is automatically generated from structured comments\sidenote{using \href{http://www.sphinx-doc.org/en/master/}{Sphinx}}, which naturally establishes a minimal level of documentation that we will require to have a task accepted into the main library. We hope the combination of these design nudges and explicit development instructions in the user guide encourages users to make contributing well-documented, reusable tasks a normal part of using Autopilot.


\subsection{Message Handling}

Modular software needs a well-defined protocol to communicate between modules, and Autopilot's is heavily influenced by the concurrency philosophy\sidenote{"ZeroMQ [...] has a subversive effect on how you develop network-capable applications. [...] message processing rapidly becomes the central loop, and your application soon breaks down into a set of message processing tasks."\\"If there's one lesson we've learned from 30+ years of concurrent programming, it is: \textit{just don't share state.}"\\\vspace{6pt}\hspace*{\fill} -\href{http://zguide.zeromq.org/}{The ZeroMQ Guide}} of ZeroMQ\citep{hintjensZeroMQMessagingMany2013}. All communication between computers and modules happens with ZeroMQ messages, and handling those messages is the main way that Autopilot handles events. A key design principle is that Autopilot components should not "share state"---they can communicate, but they are not \textit{dependent} on one another. While this may seem like a trivial detail, having networking and message-handling at its core has three advantages that make Autopilot a fundamental departure from previous behavioral software.

First, new software modules can be added to any system by simply dropping in a standalone networking object. There is no need to dramatically reorganize existing code to make room for new functionality. Instead new modules can receive, process, and send information by just connecting to a parent module in the swarm. For example, each \hyperref[sec:plotting]{plot} opens a network connection to stream incoming task data independently from the stream that is saving the data.

Second, Autopilot can be made to interact with other software libraries that use ZeroMQ. For example, The OpenEphys GUI for electrophysiology \href{https://open-ephys.atlassian.net/wiki/spaces/OEW/pages/23265310/Network+Events}{can send and receive ZMQ messages} to execute actions such as starting or stopping recordings. Interaction with other software is also useful in the case that some expensive computation needs to happen mid-task. For example, one could send frames captured from a video camera on a Raspberry Pi to a GPU computing cluster for tracking the position of the animal. Since ZeroMQ messages are just TCP packets it is also possible to communicate over the internet for remote control or to communicate with a data server.

Third, making every component network-capable allows tasks to be distributed over multiple Raspberry Pis. Chaining multiple Pis distributes the computational load, allowing, for example, one Raspberry Pi to record and process video while another runs a sound server and delivers rewards. Autopilot expands with the complexity of your task, simultaneously eliminating limitations on quantity of hardware peripherals while ensuring latency is minimal. More interestingly, distributing tasks allows the arbitrary construction of what we call "behavioral topologies," which we describe in \hyperref[sec:topology]{section \ref*{sec:topology}}.
