%!TEX root=../../autopilot.tex



\newthought{We will likely never view} Autopilot as "finished." Autopilot---like all open-source software---is an evolving project, and this paper captures it as a snapshot in its current form. We are invested in its development, and will be continually working to fix bugs, make its use more elegant, and add new features in collaboration with other researchers. 

We expect that as the codebase matures and other researchers use Autopilot in new, unexpected ways that some fundamental elements of its structure may evolve. We have built version logging into the structure of the system so that changes will not compromise the replicability of experiments (see \ref{future:provenance} below). While there will inevitably be breaking changes, these will be transparently documented, \href{https://docs.auto-pi-lot.com/en/latest/changelog/index.html}{announced in release notes}, and indicated with \href{https://semver.org/}{semantic versioning} in order to alert users and describe how to adapt as needed. 

We recognize the risk and inertia of retooling lab infrastructure, and there is still much work to be done on Autopilot. We welcome any brave early adopters with a taste for the challenge of filling the collective need for a generalizable experimental framework. Trying it is ultimately as risky as buying a Raspberry Pi. 

The current major planned changes (also see the \href{https://docs.auto-pi-lot.com/en/latest/todo.html}{todo} page in the docs) include:


\begin{enumerate}[ref=\thechapter.\arabic*]
    \item \label{future:rust}\textbf{Python, Meet Rust} - Python is very useful as a high-level glue language, and its accessibility to a large number of scientific programmers is important to us, but it has its own very real performance limitations. As Autopilot's modules mature and stabilize, we are interested in rewriting core routines like sound presentation and networking in rust and exposing them to python with tools like \href{https://github.com/PyO3/pyo3}{PyO3}
    \item \label{future:realtime}\textbf{Real Realtime} - Beneath user space decisions like programming language, the timing of CPU operations in linux is still determined by the kernel --- this is one of the major reasons why other projects are based around dedicated microcontrollers. For almost everything that most scientists want to do, the standard linux kernel is perfectly fine, but we are interested in investigating what it would take to provide true deterministic realtime performance via Autopilot's high-level object system. One approach might be to provide \href{https://github.com/ros-realtime/linux-real-time-kernel-builder}{prebuilt realtime kernel} images along with tools to easily deploy them, though no firm plan has been made.
    \item \label{item:othertools} \textbf{Integration} - We will continue to collaborate with other programming teams to be interoperable with a broader array of other tools. Our next set of planned integrations include recording electrophysiological data by integrating with Open Ephys\citep{siegleOpenEphysOpensource2017}, optical imaging data from the Miniscope project \citep{aharoniCircuitInvestigationsOpenSource2019,aharoniAllLightThat2019}, and shared processing and control pipelines with Bonsai\citep{lopesBonsaiEventbasedFramework2015b}.
    \item \label{future:data}\textbf{Data Ingest \& Export} - We are releasing Autopilot's data modeling system in v0.5.0 as an alpha release alongside this paper, and it includes prototype export interfaces to \href{https://www.nwb.org/}{Neurodata Without Borders}\citep{rubelNWBAccessibleData2019} and \href{https://www.datajoint.com/}{Datajoint}\citep{yatsenkoDataJointSimplerRelational2018a}. Over the next several releases, we will continue to clean up our data model so that researchers can easily structure their data and choose among different backends for storage. We are also working on a \href{https://github.com/auto-pi-lot/ingesture}{separate project} to make tools to ingest data from the more gestural directory-based data formats widely used in science and ingest them into Autopilot's and other tools formal modeling systems. In the longer term, we are interested in making Autopilot interoperable with linked data systems based on RDF and RDF-like standards as part of a broader vision of digital infrastructure to be articulated in future writing.
    \item \label{future:provenance}\textbf{Provenance} - Autopilot stores version information and local configuration in several different places, and it is technically possible to faithfully replicate an experiment, but some recording of provenance is still incomplete and clunky to use. By formalizing our object and data model, we will also systematize the many changes in configuration and version possible across the system for complete provenance tracking.
    \item \label{future:network}\textbf{P2P Networking} - The default tree structure of Autopilot's networking modules has proven to be unnecessarily limiting over time. In part, we had preoptimized for processing messages in a separate processes assuming that would help problems from dropped messages and overflowing send buffers, but in practice messages are almost never dropped and network nodes are as effective as stations in sending and receiving large amounts of data. As part of unifying Autopilot's object system, we will implement a fully peer-to-peer networking system such that each instantiated object has a unique ID so that messages can be easily addressed from any object to any other in its swarm. We will learn from previous p2p addressing systems like \href{https://en.wikipedia.org/wiki/Distributed\_hash\_table}{distributed hash tables} to allow net nodes to join the swarm and discover all other nodes automatically without manually configuring IP addresses and ports. Longer term we are interested in peer to peer data transfer as well, so that an object serving as a data source can efficiently stream to many consumers without needing to duplicate each message for every consumer.
    \item \label{future:slots}\textbf{Slots, Signals, and Streaming} - We will be supplementing a more general network structure with a system of specifying which attributes of each object are data sources, which are sinks, and what kind of connection they accept. Similar to Qt's \href{https://doc.qt.io/qt-6/signalsandslots.html}{signal and slot} model, we want to make it as easy as using a \texttt{.connect()} method to control one piece of hardware with another. The transforms module should also be able to support branching and forking operations so multiple data sources can be combined for elaborated hardware control. ZeroMQ is an excellent tool for sending and receiving control messages, but formalized signals and slots could also specify different streaming tools like \href{https://redis.io/}{redis} or \href{https://gstreamer.freedesktop.org/}{gstreamer} that might be better suited for high-bandwidth linear streams like video. Applied generally, this could also solve related problems like the relatively implicit handling of event triggers in the Task class.
    \item \label{future:gui} \textbf{Rebuild the GUI} - The GUI is some of the oldest code in the library, was written before most of the other modules existed, and needs to be rebuilt. We have started by remaking its central widgets to be \href{https://github.com/wehr-lab/autopilot/blob/f0d20fbf3b33f832cf31136ab7d16abe01a3e924/autopilot/gui/widgets/model.py}{generated from pydantic models} used increasingly throughout the system, but the rest of the GUI still needs to be broken up into a sensible structure that decreases code duplication and allows us to do things like provide GUI extensions via plugins. We will likely continue to use Qt for the near future, but are also exploring the idea of webassembly tools to make browser-based web interfaces for remote control.
    \item \label{future:plugins} \textbf{Plugins} - We want Autopilot's plugin system to be permissive and as natural as the scripting style that most experimental code is written in, but we still need some means of specifying dependencies on other packages and plugins, among other improvements. We will be making a plugin generator that makes a folder of plugin boilerplate, as well as tools for installing, uploading, and synchronizing versions with git and the wiki. Over time we will make all object types within Autopilot able to be extended with plugins, as well as make it possible to override and extend built-in objects.
    \item \label{future:knowledge} \textbf{Knowledge Organization} - We have been extending from mere technical proficience to more broadly consider the social systems that surround research code. The wiki was our first step, and we will continue to make more points of integration for smoothly incorporating contextual knowledge typically stored in lab notebooks into a public, collectively curated information system. We want to make it easier not only for individual researchers to use Autopilot, but make it easier for labs to coordinate work across projects without needing to rely on proprietary SaaS platforms with additional tooling for managing swarms, and moving beyond a single Autopilot wiki to a federated system of wikis for fluid continuity between "private" local coordination and "public" shared knowledge.
    \item \label{future:tests}\textbf{Tests} - Our collection of tests doesn't cover the whole codebase, and so as we do further develop will move towards a system where all new code must have tests and documentation to be integrated. We also want to integrate our tests more closely with our documentation so that researchers know which part of the code has explicit tests guaranteeing functionality.
    \item \label{future:security} \textbf{Security} - Autopilot is a networked program, and while it doesn't execute arbitrary code from network messages, there is no security model to speak of. So far this hasn't beren a problem, as we encourage only using Autopilot on a local network behind a NAT, but as we we build out our networking modules we will investigate how to incorporate identity verification systems to protect swarms from malicious messages.
    \item \label{future:metastructure}\textbf{Metastructure \& Code Quality} - Autopilot started by learning from prior projects like Phil Meier and Erik Flister's \href{http://www.ratrix.org/TheRatrix.html}{ratrix}, PyControl, and Bpod, but has evolved into something very different over the course of its development. We also started it when we were very new to Python, and will be in the process of learning best practices for quite some time. So, one of the major projects without a specific label is to clean up Autopilot's code structure to make its operation and use as transparent and reliable as possible. We are in the process of unifying Autopilot's object structure so everything is clearly typed, all configuration is explicit, and all code written to handle special cases is absorbed into more general systems. Different parts of Autopilot have had different degrees of care over time, and so we will be working to catch the oldest modules up, trim unused ones, and make sure every line in the library is documented and useful. We are working to document this process to make best practices in scientific software development more accessible to new scientific programmers.
\end{enumerate}
\end{fullwidth}

